# CORS 동작 원리

### ✔CORS(Cross-Origin Resource Sharing) 기본 이해

- CORS는 **!!!!!웹 브라우저!!!!!**가 다른 출처의 리소스에 안전하게 접근할 수 있도록 하는 보안 메커니즘입니다.
- **쉽게 웹 페이지에서 발생하는 요청의 출발지와, 요청을 받은 서버의 도메인이 다를 경우에 CORS 에러가 발생함** 
  - 이 때, **요청의 출발지는 요청을 보내는 웹 페이지가 로드된 도메인을 기준으로 결정** 됨
  - 사용자가 브라우저의 주소창에 **직접 URL을 입력하는 경우, CORS 에러 발생하지 않음** (요청의 출발지 도메인이 없으므로)
    - **동적 요청:** `https://example.com`에서 로드된 웹 페이지가 자바스크립트를 통해 `https://example.com:5040`에 데이터를 요청하는 경우, 이는 동적 요청으로 간주됩니다. 이때 요청의 출발지는 원래 페이지가 로드된 도메인(`https://example.com`)이 됩니다. 포트 번호가 다르기 때문에, 이 요청은 CORS 정책의 적용을 받음.
    - **직접 입력:**  `https://example.com`에서 로드된 웹 페이지에서 사용자가 브라우저의 주소창에 `https://example.com:5040`을 직접 입력하고 접속하는 경우, CORS 에러 발생하지 않음. 이 경우, 새로운 웹 페이지 요청이므로, 이전 페이지 (`https://example.com`)와는 별개로 처리됩니다.

- 웹 브라우저는 **서버로부터 받은 응답의 CORS 관련 헤더(`Access-Control-Allow-Origin` 등)를 검사**하여, 요청이 동일 출처 정책에 부합하는지를 판단합니다.
- CORS 정책 위반 시, 웹 브라우저는 응답 처리를 차단합니다. 서버 측 처리(데이터베이스 작업 등)에는 영향을 주지 않습니다.



### ⚽ CORS 처리에 대한 전체 흐름

- 기본적으로  CORS에 대한 검사는 **`사전 요청(client) -> 사전 요청 응답(server) -> 실제 요청(client) -> 실제 요청 응답(server)`** 순서로 이루어짐

  - 이 때, **사전 요청은 특정 조건 하에서 선택적으로 수행됨**. 

  - **사전 요청은 "비단순(simple)" 요청**에 대해 브라우저가 자동으로 수행 (사전 요청의 작성 및 수행은 개발자가 직접 하는 것이 아니라, 브라우저가 자동으로 처리)

    > **비단순 요청과 단순 요청**
    >
    > - **단순 요청(Simple Request)**: 
    >   - 특정 조건을 만족하는 요청은 "단순 요청"으로 간주되며, 사전 요청 없이 직접 서버에 전송
    >   - 단순 요청은 다음과 같은 조건을 모두 만족해야 함
    >     - HTTP 메서드가 GET, HEAD, POST 중 하나여야 합니다.
    >     - HTTP 헤더는 오직 Accept, Accept-Language, Content-Language, Content-Type 등 제한된 집합에서만 사용할 수 있으며, Content-Type의 경우에도 application/x-www-form-urlencoded, multipart/form-data, text/plain 중 하나여야 함
    >     - Readme와 같은 특수한 헤더가 포함되어 있지 않아야 합니다.
    >
    >
    > - **비단순 요청(Non-Simple Request)**
    >   - 위의 조건들 중 하나라도 만족하지 않는 경우, 요청은 "비단순 요청"으로 분류
    >   - 이러한 요청은 사전 요청을 통해 서버의 허가를 받아야 함
    >
    >



### 🎁 브라우저의 CORS 검증 과정

#### 1. (사전/실제) 응답 헤더의 아래 내용을 확인하여 브라우저가 CORS 허용을 결정함

1. **`Access-Control-Allow-Origin` 확인**
   - 이 헤더는 리소스에 접근할 수 있는 출처를 명시
   - 예를 들어, `Access-Control-Allow-Origin: https://example.com`은 `https://example.com` 출처에서만 리소스 접근을 허용한다는 것을 의미
   - **서버가 응답에 포함시킨 이 헤더의 값이 요청을 보낸 페이지의 출처와 일치하거나, 모든 출처(`*`)를 허용하는 경우에만, 브라우저는 요청을 허용**
   - 만약 이 헤더가 누락되었거나 출처가 일치하지 않는다면, 브라우저는 CORS 정책 위반으로 인해 요청을 차단합니다.
2. **실제로는 더 많은 헤더를 검사하여 CORS 허용 여부를 결정함 (인터넷 참고)**
   - 여기서는 그냥 간략하게만 적어놨음



### 📃 리버스 프록시 서버를 사용하는 경우의 CORS 처리에 대한 구체적인 과정

#### 0. 결론

- 브라우저는 CORS 정책을 검증할 때, 리버스 프록시 서버의 응답이든, 백엔드 서버의 응답이든 그 출처가 어디인지는 중요하지 않음. **중요한 것은 응답 헤더, 특히 `Access-Control-Allow-Origin` 헤더의 내용**. 이 헤더에 요청을 보낸 출처가 명시되어 있거나 모든 출처(`*`)가 허용된다면, 브라우저는 CORS를 허용된 것으로 판단하고 해당 요청을 진행시킴

#### 예시 : **클라이언트가 A 데이터를 포함한 요청을 보내고, 백엔드 서버는 이를 처리한 후 B 데이터를 응답으로 반환하는 상황 가정**

#### 1. 리버스 프록시 서버에 CORS 헤더를 추가하는 경우

1. **클라이언트 요청 발생**: 클라이언트(웹 브라우저)가 A 데이터를 포함하여 리버스 프록시(Nginx)에 요청
2. **리버스 프록시에서 요청 처리**: 리버스 프록시가 요청을 받고 설정에 따라 백엔드 서버로 전달
3. **백엔드 서버에서 요청 처리**: 백엔드 서버(Spring 애플리케이션 등)에서 요청을 받아 A 데이터를 DB에 저장하고, 응답으로 B 데이터를 생성
4. **응답이 리버스 프록시로 반환**: 백엔드 서버의 응답(B 데이터)이 리버스 프록시로 다시 전달
5. **리버스 프록시에서 CORS 헤더 추가**: 리버스 프록시가 응답에 CORS 관련 헤더(`Access-Control-Allow-Origin` 등)를 추가
6. **클라이언트에 응답 전달**: 수정된 응답이 클라이언트에게 전달
7. **웹 브라우저에서 CORS 검사**: 클라이언트(웹 브라우저)는 응답의 CORS 헤더를 검사하여 정책을 충족하는지 확인
8. **CORS 정책 충족 여부에 따른 처리**: 충족하면 B 데이터에 접근할 수 있고, 충족하지 않으면 접근이 차단

#### 2. 백엔드 서버에서 CORS 헤더를 추가한 경우:

1. **클라이언트 요청 발생**: 클라이언트(웹 브라우저)가 A 데이터를 포함하여 리버스 프록시(Nginx)에 요청

2. **리버스 프록시에서 요청 처리**: 리버스 프록시가 요청을 받고 설정에 따라 백엔드 서버로 전달

3. **백엔드 서버에서 요청 처리 및 CORS 헤더 추가**: 백엔드 서버에서는 A 데이터를 처리(예: DB 저장)하고, 응답으로 B 데이터를 반환하면서 응답에 CORS 헤더를 포함

4. **응답이 리버스 프록시를 거쳐 클라이언트로 전달**: 백엔드 서버의 응답이 리버스 프록시를 거쳐 클라이언트에게 전송. 리버스 프록시는 백엔드에서 설정한 CORS 헤더를 유지.

5. **웹 브라우저에서 CORS 검사**: 클라이언트(웹 브라우저)는 응답의 CORS 헤더를 검사하여 정책을 충족하는지 확인

6. **CORS 정책 충족 여부에 따른 처리**: 충족하면 B 데이터에 접근할 수 있고, 충족하지 않으면 접근이 차단

> 두 경우 모두 최종적으로 클라이언트에서 받은 응답의 CORS 헤더를 바탕으로 웹 브라우저가 CORS 정책 위반 여부를 판단하며, 이 과정에서 요청 출처와 응답의 `Access-Control-Allow-Origin` 헤더 값이 일치하는지가 핵심