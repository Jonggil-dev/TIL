# CORS 동작 원리

### ✔CORS(Cross-Origin Resource Sharing) 기본 이해

- CORS는 **!!!!!웹 브라우저!!!!!**가 다른 출처의 리소스에 안전하게 접근할 수 있도록 하는 보안 메커니즘입니다.
- **쉽게 웹 페이지에서 발생하는 요청의 출발지와, 요청을 받은 서버의 도메인이 다를 경우에 CORS 에러가 발생함** 
  - 이 때, **요청의 출발지는 요청을 보내는 웹 페이지가 로드된 도메인을 기준으로 결정** 됨
  - 사용자가 브라우저의 주소창에 **직접 URL을 입력하는 경우, CORS 에러 발생하지 않음** (요청의 출발지 도메인이 없으므로)
    - **동적 요청:** `https://example.com`에서 로드된 웹 페이지가 자바스크립트를 통해 `https://example.com:5040`에 데이터를 요청하는 경우, 이는 동적 요청으로 간주됩니다. 이때 요청의 출발지는 원래 페이지가 로드된 도메인(`https://example.com`)이 됩니다. 포트 번호가 다르기 때문에, 이 요청은 CORS 정책의 적용을 받음.
    - **직접 입력:**  `https://example.com`에서 로드된 웹 페이지에서 사용자가 브라우저의 주소창에 `https://example.com:5040`을 직접 입력하고 접속하는 경우, CORS 에러 발생하지 않음. 이 경우, 새로운 웹 페이지 요청이므로, 이전 페이지 (`https://example.com`)와는 별개로 처리됩니다.

- 웹 브라우저는 **서버로부터 받은 응답의 CORS 관련 헤더(`Access-Control-Allow-Origin` 등)를 검사**하여, 요청이 동일 출처 정책에 부합하는지를 판단합니다.
- CORS 정책 위반 시, 웹 브라우저는 응답 처리를 차단합니다. 서버 측 처리(데이터베이스 작업 등)에는 영향을 주지 않습니다.



### ⚽ CORS 처리에 대한 전체 흐름

- 기본적으로  CORS에 대한 검사는 **`사전 요청(preflight, client) -> 사전 요청 응답(server) -> 실제 요청(client) -> 실제 요청 응답(server)`** 순서로 이루어짐

- **사전 요청은 "비단순(simple)" 요청에 대해서만 브라우저가 자동으로 수행**

  - **단순 요청 (Simple Request) : 다음 조건을 모두 만족해야 단순 요청으로 간주**

    - **HTTP 메서드**: `GET`, `POST`, 또는 `HEAD` 메서드 중 하나일 때.

    - 요청에 포함된 헤더의 `Content-Type`이 아래 중 하나일 때
      - `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`

    - **사용자 정의 헤더 미사용**: 기본적인 HTTP 헤더 외의 사용자 정의 헤더가 없어야 함 (예: `Authorization`, `X-Custom-Header`와 같은 헤더를 사용하지 않을 때).

  - **비단순 요청 : 단순 요청에 해당하지 않는 요청**

- **Restful API에서는 `Content-Type`이 `application/json` 이고 `Authorization` 같은 사용자 정의 헤더가 있으므로, 비단순 요청이 대부분임 -> 즉, 대부분 사전요청이 발생함 -> 즉, 리버스 프록시 서버에 CORS를 설정하게 되면 서버 부하를 줄일 수 있음. 불필요한 요청을 애플리케이션 서버(Sprint 서버)까지 전달하지 않고 Nginx 레벨의 사전 요청에서 차단할 수 있기 때문**

### 🎁 브라우저의 CORS 검증 과정

#### 1. (사전/실제) 응답 헤더의 아래 내용을 확인하여 브라우저가 CORS 허용을 결정함

1. **`Access-Control-Allow-Origin` 확인**
   - 이 헤더는 리소스에 접근할 수 있는 출처를 명시
   - 예를 들어, `Access-Control-Allow-Origin: https://example.com`은 `https://example.com` 출처에서만 리소스 접근을 허용한다는 것을 의미
   - **서버가 응답에 포함시킨 이 헤더의 값이 요청을 보낸 페이지의 출처와 일치하거나, 모든 출처(`*`)를 허용하는 경우에만, 브라우저는 요청을 허용**
   - 만약 이 헤더가 누락되었거나 출처가 일치하지 않는다면, 브라우저는 CORS 정책 위반으로 인해 요청을 차단합니다.
2. **실제로는 더 많은 헤더를 검사하여 CORS 허용 여부를 결정함 (인터넷 참고)**
   - 여기서는 그냥 간략하게만 적어놨음
   - 

### 📃 리버스 프록시 서버를 사용하는 경우의 CORS 처리에 대한 구체적인 과정

#### 0. 결론

- 브라우저는 CORS 정책을 검증할 때, 리버스 프록시 서버의 응답이든, 백엔드 서버의 응답이든 그 출처가 어디인지는 중요하지 않음. **중요한 것은 응답 헤더, 특히 `Access-Control-Allow-Origin` 헤더의 내용**. 이 헤더에 요청을 보낸 출처가 명시되어 있거나 모든 출처(`*`)가 허용된다면, 브라우저는 CORS를 허용된 것으로 판단하고 해당 요청을 진행시킴
- **그리고 사전 요청 덕분에 리버스 프록시 서버에 CORS를 설정하게 되면 서버 부하를 줄일 수 있음. 불필요한 요청을 애플리케이션 서버(Sprint 서버)까지 전달하지 않고 Nginx 레벨에서 차단할 수 있기 때문**

#### 예시 : **클라이언트가 A 데이터를 포함한 요청을 보내고, 백엔드 서버는 이를 처리한 후 B 데이터를 응답으로 반환하는 상황 가정**

#### 1. 리버스 프록시 서버에 CORS 헤더를 추가하는 경우

1. **클라이언트 사전 요청 발생 (비단순 요청일 경우)**: 클라이언트(웹 브라우저)가 A 데이터를 포함하여 리버스 프록시(Nginx)에 요청
2. **리버스 프록시에서 사전 요청 처리**: Nginx에 CORS 설정이 있는 경우, **사전 요청을 Nginx가 처리하고** CORS 헤더를 응답에 추가
   - Nginx가 사전 요청에 대해 직접 응답하므로, 애플리케이션 서버로 전달되지 않음
3. **클라이언트에서 본 요청 발생** : 사전 요청에 실패하면 CORS 에러 발생, 성공하면 본 요청 발생
4. **리버스 프록시에서 본 요청 전달**: 리버스 프록시가 본 요청을 받고  백엔드 서버로 요청을 프록시
5. **백엔드 서버에서 요청 처리**: 백엔드 서버(Spring 애플리케이션 등)에서 요청을 받아 A 데이터를 DB에 저장하고, 응답으로 B 데이터를 생성
6. **응답이 리버스 프록시로 반환**: 백엔드 서버의 응답(B 데이터)이 리버스 프록시로 다시 전달
7. **리버스 프록시에서 CORS 헤더 추가**: 리버스 프록시가 응답에 CORS 관련 헤더(`Access-Control-Allow-Origin` 등)를 추가
8. **클라이언트에 응답 전달**: 수정된 응답이 클라이언트에게 전달
9. **웹 브라우저에서 CORS 검사**: 클라이언트(웹 브라우저)는 응답의 CORS 헤더를 검사하여 정책을 충족하는지 확인
10. **CORS 정책 충족 여부에 따른 처리**: 충족하면 B 데이터에 접근할 수 있고, 충족하지 않으면 접근이 차단

#### 2. 백엔드 서버에서 CORS 헤더를 추가한 경우:

1. **클라이언트 사전 요청 발생 (비단순 요청일 경우)**: 클라이언트(웹 브라우저)가 A 데이터를 포함하여 리버스 프록시(Nginx)에 요청
2. **리버스 프록시에서 사전 요청 전달**: Nginx에 CORS 설정이 없으면 사전 요청을 그대로 백엔드 서버로 전달
3. **클라이언트에서 본 요청 발생** : 사전 요청에 실패하면 CORS 에러 발생, 성공하면 본 요청 발생
4. **백엔드 서버에서 사전 요청 처리 및 CORS 헤더 추가**: 백엔드 서버는 사전 요청에 대해 CORS 헤더를 포함해 응답을 반환
5. **웹 브라우저에서 CORS 정책 확인 후 본 요청 발생**: 사전 요청의 응답을 확인한 클라이언트는 A 데이터를 포함한 본 요청을 다시 Nginx에 전송
6. **리버스 프록시에서 본 요청 전달**: 리버스 프록시가 요청을 받고 설정에 따라 백엔드 서버로 전달
7. **백엔드 서버에서 요청 처리 및 CORS 헤더 추가**: 백엔드 서버에서는 A 데이터를 처리(예: DB 저장)하고, 응답으로 B 데이터를 반환하면서 응답에 CORS 헤더를 포함
8. **응답이 리버스 프록시를 거쳐 클라이언트로 전달**: 백엔드 서버의 응답이 리버스 프록시를 거쳐 클라이언트에게 전송. 리버스 프록시는 백엔드에서 설정한 CORS 헤더를 유지.
9. **웹 브라우저에서 CORS 검사**: 클라이언트(웹 브라우저)는 응답의 CORS 헤더를 검사하여 정책을 충족하는지 확인
10. **CORS 정책 충족 여부에 따른 처리**: 충족하면 B 데이터에 접근할 수 있고, 충족하지 않으면 접근이 차단

> 두 경우 모두 최종적으로 클라이언트에서 받은 응답의 CORS 헤더를 바탕으로 웹 브라우저가 CORS 정책 위반 여부를 판단하며, 이 과정에서 요청 출처와 응답의 `Access-Control-Allow-Origin` 헤더 값이 일치하는지가 핵심