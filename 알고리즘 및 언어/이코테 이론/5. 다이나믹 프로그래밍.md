# 5. 다이나믹 프로그래밍

### 0. 코딩 테스트

- 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 확인

- 해결하고자 하는 부분 문제들의 중복 여부를 확인

- 가능하다면 **탑다운 방식보다는 바텀업 방식으로 구현하는 것을 권장** (탑다운은 재귀 깊이 한정으로 인한 에러가 날 수 있기 때문에)

### 1. 정의

- 메모리 공간을 더 사용하면서 연산 속도를 비약적으로 증가시키기 위해 탄생  
  → **결국, 먼저 계산했던 결과값을 저장할 추가적인 배열 or 자료구조를 만들어야 함**

- **큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 해결하는 알고리즘 기법**  

- **쉽게 정의하면 연산한 내용을 기억해놓고 다음에 그 연산이 필요할 때 꺼내서 쓰는 알고리즘**

### 2. 사용 조건

    (1) 큰 문제를 작은 문제로 나눌 수 있다.

    (2) 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

    → **가장 대표적인 유형이 피보나치 수열**

### 3. 메모이제이션(Memoization)

- 나중에 동일한 문제를 풀어야 할 때 이미 저장한 값을 반환하기 위해 한 번 푼 문제는 그 결과를 저장해 놓는 것을 메모이제이션 이라고 함 (다이나믹 프로그래밍과 구분 215page 참고)

- 다이나믹 프로그래밍을 구현하는 방법 중 하나로, 값을 저장하는 방법이므로  캐싱(cashing)이라고도 한다.

- 예시 코드(피보나치 수열)
  
  ```
  # 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
  d =[] * 100
  
  # 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
  def fibo(X):
      # 종료 조건(1 혹은 2일 때 1을 반환)
      if x == 1 or x == 2:
          return 1
  
      # 이미 계산한 적 있는 문제라면 그대로 반환
      if d[x] != 0:
          return d[x]
  
      d[x] = fibo(X-1) + fibo(X-2)
      return d[x]
  ```

### 4. 방식

  (1) 탑다운 방식 : **재귀함수**를 이용하여 구현, 큰 문제를 해결하기 위해 작은 문제를 호출

         - 메모제이션은 탑다운 방식에 국한되어 사용되는 표현

  (2) 바텀업 방식 : **반복문**을 이용하여 구현, 작은 문제부터 차근차근 답을 도출 

          - 바텀업에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 부름

```
# 피보나치 수열 탑다운 방식
    위 예시 코드 참고

# 피보나치 수열 바텀 업 방식
d = [0] * 100

d[1] = 1
d[2] = 2
n = 99

for i in range(3,n+1):
    d[i] = d[i-1] + d[i-2] 
```
