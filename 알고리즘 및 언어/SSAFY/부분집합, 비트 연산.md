# 부분집합

### 1. 부분집합의 수(공집합 포함) : 2^n

→ 각 원소를 부분집합에 포함 시키거나 포함시키지 않는 2가지 경우의 수를 모든 원소에 적용 하면 2^n개가 됨

### 2. 부분집합 생성하는 코드

```
Arr = [1, 2, 3, 4]
bit = [0, 0, 0, 0] #비트가 1이 되면 Arr원소가 부분집합에 포함, 0이면 미포
for i in range(2) :
    bit[0] = i
    for j in range(2) :
        bit[1] = j
        for k in range(2) :
            bit[2] = k
            for l in range(2) :
                bit[3] = l
                print(bit)
```

# 비트 연산

### 1. 비트 : 데이터를 표현하는 작은 단위

: 메모리 안에 저장된 데이터들은 비트로 표현 됨. 
→ 메모리는 비트를 저장하는 공간, 비트는 그저 두 가지 값(0,1)을 나타내는 작은 정보의 표현 방식.

### 2. 비트 연산자

    (1) & : 비트 단위로 AND 연산 수행

    (2) | : 비트 단위로 OR 연산 수행

    (3) << : 피연산자의 비트 열을 왼쪽으로 이동 (ex) 1<<n : 1의 비트 열을 n만큼 왼쪽으로                    이동

    (4) >> : 피연산자의 비트 열을 오른쪽으로 이동

### 3. 비트 연산으로 부분 집합 만들기

: 먼저 가능한 부분 집합의 모든 경우를 이진수 형태로 표현 한 뒤,
  이진수 형태에 대응하는 리스트의 각 요소들을 뽑아내는 방법

```
    A = [1,2,3,4,5,6,7,8,9,10,11,12]
    N = len(A)
    total_part_ls=[] # 생성되는 부분 집합들을 하나의 리스트에 담기 위함

    for i in range(1<<N): # 모든 부분 집합을 이진수 형태로 변경하여 확인하기 위함
        each_part_ls =[]  # 생성되는 각각의 부분 집합을 담기 위함
        for j in range(N): # A의 각 요소가 부분 집합에 포함되어 있는지 확인하기 위한 세팅
            if i & (1<<j): # 부분 집합의 이진수 형태에 A요소가 포함되어 있다면
                each_part_ls.append(A[j]) # 이진수 1에 해당하는 요소을 해당 요소로 뽑아내라
        total_part_ls.append(each_part_ls)
    
    
    ※ 여기서 1<<j 는 A의 j번째 인덱스 요소를 이진법상 위치로 바꾼거임
```






