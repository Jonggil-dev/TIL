# 얕은복사,깊은복사 

```
list_1 = [1,2,3]
list_2 = list_1
list_1[0] = 100

print(list_2) # print(list_2)의 경우 [100,2,3]으로 출력됨  
```

### 1. list_2 = list_1  
     이 방식은 list_2와 list_1이 동일한 객체를 참조함. 즉, 같은 메모리 주소를 가리키므로 list_2가 변경되면 list_1도 동일한 변경 사항을 반영함.

### 2. list_2 = list_1[:] or list_1.copy() → **얕은복사**
     리스트를 얕은 복사(shallow copy)하는 방법으로 원본 리스트와 복사본의 최상위 레벨 요소들은 서로 다른 객체를 가리키지만, 내부 객체들은 객체type에 따라 '값 또는 참조 값' 복사가 이루어짐.

   (1) immutable 값 (불변 객체: 정수, 실수, 문자열, 튜플 등):  
          슬라이싱을 통해 새로운 리스트, 튜플, 문자열 등을 생성하면, 해당 객체의 값을 heap 메모리에 복사하여 새로운 객체를 생성합니다.
          **따라서 슬라이싱된 객체와 원본 객체는 서로 다른 값을 가지고 있으며**, 변경하더라도 서로에게 영향을 주지 않습니다.

   (2)mutable 값 (가변 객체: 리스트, 딕셔너리, 집합 등):
          슬라이싱을 통해 해당 객체의 참조(주소)를 heap 메모리에 복사합니다. 즉, 새로운 객체는 원본 객체의 요소들을 참조합니다.
          **따라서 슬라이싱된 객체와 원본 객체는 같은 객체를 참조하게 됩니다.** 이러한 경우, 원본 객체를 변경하면 슬라이싱된 객체도 변경사항을 따라갑니다.  


![메모리 할당 과정_얕은복사](https://github.com/JeongJonggil/TIL/assets/139416006/5294dbc5-7a23-4867-9ad0-ccb26bc46c16)


### 3. list_2 = copy.deepcopy(list_1) → **깊은복사**
    copy 모듈의 deepcopy() 함수를 사용하면 값을 복사하여 메모리에 별도로 생성함. 원본 리스트를 수정해도 사본에 영향을 주지 않음.

![메모리 할당 과정_깊은복사](https://github.com/JeongJonggil/TIL/assets/139416006/3accb6d5-ed12-441a-9829-7ae02d3bc0ef)

  

