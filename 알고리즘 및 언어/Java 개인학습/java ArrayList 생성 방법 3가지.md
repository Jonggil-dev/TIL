# java ArrayList 생성 방법 3가지

### 0. 참고

- https://inpa.tistory.com/entry/JAVA-☕-ArraysasList-와-Listof-차이-한방-정리 [Inpa Dev 👨‍💻:티스토리]

### 1. `new ArrayList<>(), Arrays.asList(), List.of()`의 차이

| 특징                                | `new ArrayList<>()`                  | `Arrays.asList()`                      | `List.of()`                            |
| ----------------------------------- | ------------------------------------ | -------------------------------------- | -------------------------------------- |
| **생성 방식**                       | 새로운, 가변 크기의 ArrayList 생성   | 고정 크기의 리스트 생성                | 불변 리스트 생성                       |
| **요소 추가/삭제<br />(크기 조절)** | 요소 추가/삭제 가능<br />(동적 크기) | 요소 추가/제거 불가능<br />(고정 크기) | 요소 추가/제거 불가능<br />(고정 크기) |
| **요소 수정**                       | 수정 가능<br />(set 메서드)          | 수정 가능 <br />(set 메서드)           | 수정 불가<br />(불변 리스트)           |
| **Null 값**                         | Null 값 허용                         | Null 값 허용                           | Null 값 허용<br />(Java 9 이상)        |
| **성능**                            | 많은 메모리 사용 가능                | 적은 메모리 사용                       | 가장 낮은 메모리 사용                  |



### 2. `Arrays.asList(), List.of()` 객체 생성 방식

- `Arrays.asList()`와 `List.of()`의 **반환 리스트는 java.util.ArrayList가 아님**
  **(`new ArrayList<>()`와 이름만 같은거고 다른 객체임)**

- `Arrays.asList()`는 List 객체를 만들 때 **인자로 받은 원본 배열의 주소값**을 사용함(얕은 복사)

  - **즉, 참조한 원본 배열의 값이 바뀌면 리스트의 값도 바뀌고, 반대로 리스트의 값을 수정해도 원본 배열의 값도 바뀜**

- 반면, `List.of()`는 List 객체를 만들 때 **인자로 받은 원본 배열의 원소를 일일히 순회하여 값을 복사함**

  - **즉, 참조한 원본 배열의 값이 바뀌어도 리스트의 값은 바뀌지 않음 (반대의 경우도 마찬가지)**

    

### 3. `Arrays.asList(), List.of()`의 필요성

- `Arrays.asList()` 와 `List.of()`를 사용하는 이유는 **불변 객체만의 이점과 리스트 객체의 다양한 메서드를 사용하기 위해서임**
  1. **변경 불가능성**:
     - 불변 리스트는 생성된 후 요소를 추가하거나 삭제할 수 없습니다. 이로 인해 데이터의 일관성을 보장할 수 있습니다.
     - 프로그램의 여러 부분에서 같은 리스트를 참조하더라도, 그 리스트의 내용이 변경되지 않기 때문에 예측 가능한 동작을 유지할 수 있습니다.
  2. **스레드 안전성**:
     - 불변 객체는 멀티스레드 환경에서 안전하게 사용될 수 있습니다. 여러 스레드가 동시에 리스트를 읽더라도, 데이터의 변경이 없으므로 동기화 문제를 피할 수 있습니다.
  3. **성능 최적화**:
     - 불변 객체는 메모리 사용을 최적화할 수 있습니다. 예를 들어, 여러 리스트를 생성할 필요 없이 동일한 불변 리스트를 여러 곳에서 참조할 수 있습니다.
     - 불변 리스트는 내부적으로 캐시를 활용하여 성능을 향상시킬 수 있습니다.
  4. **기타 컬렉션으로의 변환 용이성**:
     - 불변 리스트는 다른 컬렉션 자료구조로 쉽게 변환될 수 있습니다. 예를 들어, 불변 리스트를 `Set`이나 `Map`으로 변환할 수 있으며, 이 과정에서 데이터의 일관성을 유지할 수 있습니다.
     - 불변 리스트를 사용하면, 데이터를 안전하게 다른 구조로 변환할 수 있어, 코드의 안정성과 가독성을 높입니다.
  5. **리스트는 다양한 메서드 제공**: `List` 인터페이스는 다양한 메서드를 제공하여, 데이터 처리에 더 유연성을 줍니다. 예를 들어, 정렬, 검색 등의 기능을 사용할 수 있습니다.