# for문 내부 동작

- Python의 `for` 문은 이터레이터를 기반으로 작동하지만, 이터레이터는 내부적으로 현재 순회 중인 요소의 인덱스를 관리하고 있음

> **이터레이터(iterator)** 
>
> - Python에서 반복 가능한 객체를 순회할 수 있도록 해주는 객체.
> - 간단히 말하면, 반복 가능한 객체에서 데이터를 순차적으로 꺼낼 수 있는 도구
> - **이터레이터를 생성할 때, 이터레이터는 다음 두 가지 정보를 가지고 있게 됨**
>   1. **현재 위치의 참조(인덱스)**: 이터레이터는 반복 중인 컬렉션 내에서 현재 접근하고 있는 요소의 위치를 내부적으로 관리함. 예를 들어, 리스트의 경우 현재 요소의 인덱스가 해당함
>   2. **반복 대상 객체의 참조**: 이터레이터는 반복하고 있는 객체(예: 리스트, 딕셔너리, 세트 등)에 대한 참조도 유지. 이 참조를 통해 컬렉션의 다음 요소에 접근할 수 있음

1. **이터레이터의 작동 원리**:
    - Python의 `for` 문이 실행될 때,  `__iter__()` 메서드를 호출하여 이터레이터를 생성
    - 이터레이터는 `__next__()` 메서드를 사용하여 컬렉션에서 다음 요소를 반환합니다. 이 과정에서 내부적으로 현재 순회 장소의 인덱스를 추적하며, 각 `__next__()` 호출 시 해당 인덱스를 하나씩 증가
    - **인덱스가 리스트를 벗어나게 되면 StopItertation 예외를 발생시켜 순회를 종료 시킴**
    
2. **인덱스 변경의 영향**:
    - **이터레이터는 인덱스를 기반으로 다음 요소를 찾기 때문에, 이터레이터가 참조하고 있는 컬렉션의 요소의 개수가 바뀌어 인덱스가 조정되면 예상치 못한 결과가 발생할 수 있음**

### 예시

```python
numbers = [10, 20, 30, 40, 50]
for number in numbers:
    if number == 10:
        numbers.remove(number)  # '10'을 제거하고 리스트는 [20, 30, 40, 50]가 됨
    print(number)  # 출력: 10, 30, 40, 50
```

위의 예제에서는 다음과 같은 현상이 발생합니다:
- 인덱스 "0"과 numbers 리스트를 참조하는 이터레이터 생성 
- '10'을 처리한 후, '10'이 numbers에서 제거 됨
- 이터레이터는 내부적으로 `__next()__`  메서드를 호출하여, 인덱스를 1로 증가시킴
- 참조하고 있던 numbers 리스트에서 요소 "10"이 제거되면서 인덱스 1번은 "30"이 됨
- 결과적으로 "20"은 출력되지 않고 건너뛰어짐
