# 자율 프로젝트 고민 사항 모음

### 1. Fcm 토큰의 경우 로그인 할 때 User 서버에서 요청 받지만, Notification 서버와 연결된 DB(몽고)로 저장해야 되는데 어떻게?

- 각 서버의 독립성을 생각해보면 자녀 ID와 Fcm 토큰을 Kafka에 넣고 Notification에서 수신해서 저장하도록 하는게 제일 바람직해 보임 -> 이 방법이 아니면 결국 Notification 서비스가 내려갔을 때 자녀 회원 가입에 영향을 미치게 됨

### 2. 회원 가입 시 소프트 딜리트 유저 확인하는 로직 추가 

- 탈퇴 유저의 LoginID, PhoneNumber, DeviceId는 다시 쓸 수 있어야 됨
- 구현 방법
  - **유니크 인덱스 수정 (필터링된 인덱스 또는 부분 인덱스 사용)**
    - 소프트 딜리트된 레코드에 대해 필드의 유니크 인덱스를 비활성화하고, 활성 사용자에 대해서만 유니크 제약 조건을 유지하는 방법

  - **로그인 ID 변경 (타임스탬프, UUID, 접두사 사용)**
    - 소프트 딜리트 처리 시, LoginId에 타임스탬프, UUID, 또는 특정 접두사를 추가하여 고유성을 깨뜨리는방법. 예를 들어, 사용자가 탈퇴하면 LoginId를 "deleted_" + 원래 LoginId로 변경할 수 있습니다

- 채택
  - **로그인 ID 변경 (타임스탬프(초단위 까지) 접두사 사용)**
  - 이유
    - 데이터베이스 구조나 인덱스 설정을 변경할 필요가 없어, 유니크 인덱스 관리가 쉬움
    - 특별한 데이터베이스 기능을 요구하지 않아 호환성이 좋음.

### 3. Access-Token, Refresh-Token Secret-Key 분리

- 일반적으로?는 하나의 Secret-key를 이용해 Access-Token, Refresh-Token을 생성하는 거 같음. 그러나 하나의 Secret-Key를 사용하면 refresh_token을 헤더에 access_token 대신 담아서 보내도 인증이 허가가 됨

- 각 토큰의 용도에 맞는 역할만 수행하기 위해 토큰 별로 Secret-Key를 달리하여 토큰을 생성하기로 함



### 4. Security에 커스텀 필터인 JwtAuthenticationFilter를 등록하고 사용하는데 1번의 request가 해당 필터를 자꾸 2번 실행하는 에러 (필터 중복 등록 에러)

- 참고 : [바로가기](https://shanepark.tistory.com/497)

- **원인**

  - `JwtAuthenticationFilter`를 간편하게 Bean으로 등록 해두고 사용하려고 클래스에 `@Component` 어노테이션을 붙여서 사용했는데 그게 원인으로 추정 됨

  - 스프링 빈으로 등록된 Servlet, Filter, Listener 인스턴스들은 내장 컨테이너에 자동으로 등록 됨. 특히 Filter 빈을 등록하면 어플리케이션의 생명주기에서 매우 이른시기에 등록되기 때문에 다른 빈들과 상호작용이 필요하다면 `DelegatingFilterProxyRegistrationBean` 을 고려하라고 함.

    > 예전에 스프링 프레임워크를 배울때는 필터와 인터셉터의 차이에 대해 스프링의 관여 여부를 따지곤 했었는데, `DelegatingFilterProxyRegistrationBean` 덕분에 스프링이 관리하는 필터도 서블릿 필터 체인에 등록할 수 있게 되었다.

  - 그러니 원인을 분석해보자면 똑같은 필터가 자동으로, 수동으로 총 2번 등록되었다는 이야기다. 자동으로 등록된 필터의 문제점은, URL 패턴 없이 그냥 모든 요청을 대상으로 다 적용이 되며 특히 순서를 보장하기도 굉장히 까다롭다는 것이다.

- **해결**

  - 필터가 자동으로 등록되지 않도록 `@Component` 어노테이션을 제거한다.

  - 스프링 시큐리티 설정파일에서는 해당 `Filter`를 생성자를 통해 생성해 필터체인에 등록

    ```java
    public class SecurityConfig {
         			
                        ...중략
        @Bean
        public SecurityFilterChain filterChain(HttpSecurity httpSecurity, AuthenticationManager authenticationManager) throws Exception {
            LoginIdAuthenticationFilter loginIdAuthenticationFilter = new LoginIdAuthenticationFilter(authenticationManager, customAuthenticationSuccessHandler, objectMapper);
            JwtAuthenticationFilter jwtAuthenticationFilter = new JwtAuthenticationFilter(jwtUtil, objectMapper);
            return httpSecurity               
                	... 중략
                    .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                    .build();
        }
    
    //@Component 빼기
    public class JwtAuthenticationFilter extends OncePerRequestFilter {
    				...중략
    }
    ```
    
    

### 5. userRepository의 save메서드에서 duplicate key 에러가 발생했는데, 응답이 CustomAuthenticationEntryPoint의 코드로 처리 되는 버그

- **상황**

  - `/api/users` 요청에 대해, `UserService` 클래스에서 `Duplicate Key` 에러가 발생했으나 해당 에러에 대해 명시적으로 핸들링되고 있지 않았음. 그런데 클라이언트에게는 `Security FilterChain`의 `AuthenticationException`의 핸들링을 담당하는 `CustomAuthenticationEntryPoint`에 작성된 응답이 반환됨

- **해결 과정**

  - `JwtAuthenticiationFilter`에 문제가 있을걸로 예상하고. Sout과 Intellij의 디버거를 사용해 디버깅을 해보니 3가지 문제점을 발견함

    1. `request`가 `Controller` 매핑 전 `FilterChain`을 통과하는 과정에서 `JwtAuthenticiationFilter`가 2번 호출돼서 `filterhain.doFilter()`전 작성된 로직이 2번 실행되는 현상을 발견
       -> 위의 4번 에러 및 고민을 통해 해결

    2. `JwtAuthenticiationFilter`에서  `filterhain.doFilter()` 이후에  작성된 부분이 응답이 반환되는 과정에서 실행(후처리) 되는 건지를 몰랐음 -> `filterhain.doFilter()` 이후에 return을 추가해서 후처리 부분을 없애서 해결

       - ```java
         @RequiredArgsConstructor
         public class JwtAuthenticationFilter extends OncePerRequestFilter {
         			
         			... 중략
                 if (skip) {
                     filterChain.doFilter(request, response);
                     return; // return 추가
                 }
               
                 	... 중략
             }
         ```

    3. **(중요) 위 2가지를 해결한 상태로 디버깅을 했는데, `/api/users`요청에 대해 Service로직에서 에러가 발생하고 `/api/error` URL로 request가 다시 실행되는 과정을 발견함** 

       -  `UserService`에서 발생한 `Duplicate Key` 에러는 명시적인 핸들링이 되지 않는 상황이었고, Spring에 기본 내장된 `BasicErrorController` 가 에러를 처리하게 됨. 
       - **`BasicErrorController`의 에러 처리는 예외가 발생하면 기본적으로 `/error`  URL로 리다이렉트 하는 것임.** 그래서 `/api/error` URL로 request가 다시 한 번 실행되는 것이었음
       - 리다이렉트 된 `/api/error` request가 `filterChain`을 통과 하면서  `AuthenticationException`가 발생. (인증되지 않은 클라이언트가 인증된 URL로 접근을 시도해서 발생)
       - `filterChain`에서 발생한 `AuthenticationException`에 대해서는 `CustomAuthenticationEntryPoint`가 핸들링 하기 때문에 `CustomAuthenticationEntryPoint`에 작성된 `response`가 반환된 것임
       - **결국, `SecurityConfig`에 `/error` URL에 대해 `permitall()`을 적용시켜 `/error `리다이렉션 요청이 진행하는 과정에서 `AuthenticationException`이 발생하지 않도록 조치하여 정상적인 응답이 반환되도록 해결함**

- **핵심 요약**

  - `AuthenticationEntryPoint`에 작성된 응답이 반환되었던 이유

    - ```java
      // 첫 번째 /api/users Request 처리 과정
      1. /api/users Request -> WAS -> 필터 -> 서블릿(디스패처 서블릿) -> 인터셉터 -> 컨트롤러 -> 서비스 로직(예외 발생) -> 컨트롤러 -> 명시적인 핸들링 없음 -> BasicErrorController(스프링 MVC의 기본 예외 처리) -> /error로 리다이렉션 -> 서블릿(디스패처 서블릿) -> 인터셉터 -> 필터 -> WAS(/error 요청 생성)
      
      // 두 번째 /api/error requset 처리 과정
      // properties에 작성된 prefix설정 때문에 /api 접두사가 붙음
      2. WAS(/api/error Request 생성) -> 필터
      -> /api/error은 인증이 필요한 URL로 AuthenticationException 발생
      -> AuthenticationEntryPoint 응답 생성
      -> WAS
      -> Client 응답 반환
          
      ▣ 참고
      FilterChain에서 발생한 예외는 보안 관련 예외이기 때문에, 시스템의 무결성과 사용자의 보안을 지키기 위해 빠른 응답이 필요함. 이를 위해 FilterChain을 역순으로 거슬러 올라가지 않고 WAS를 통해 바로 클라이언트에게 응답을 전송하는 방식을 사용함.
      ```
  
  - **해결 방법**
    - `/error` URL에 대해 `permitall()`을 적용시켜 리다이렉션으로 인한 `/error`요청에 대해`AuthenticationException`이 발생하지 않도록 함
