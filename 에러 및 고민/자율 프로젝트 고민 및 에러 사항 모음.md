# 자율 프로젝트 고민 사항 모음

### 1. Fcm 토큰의 경우 로그인 할 때 User 서버에서 요청 받지만, Notification 서버와 연결된 DB(몽고)로 저장해야 되는데 어떻게?

- 각 서버의 독립성을 생각해보면 자녀 ID와 Fcm 토큰을 Kafka에 넣고 Notification에서 수신해서 저장하도록 하는게 제일 바람직해 보임 -> 이 방법이 아니면 결국 Notification 서비스가 내려갔을 때 자녀 회원 가입에 영향을 미치게 됨

### 2. 회원 가입 시 소프트 딜리트 유저 확인하는 로직 추가 

- 탈퇴 유저의 LoginID, PhoneNumber, DeviceId는 다시 쓸 수 있어야 됨
- 구현 방법
  - **유니크 인덱스 수정 (필터링된 인덱스 또는 부분 인덱스 사용)**
    - 소프트 딜리트된 레코드에 대해 필드의 유니크 인덱스를 비활성화하고, 활성 사용자에 대해서만 유니크 제약 조건을 유지하는 방법

  - **로그인 ID 변경 (타임스탬프, UUID, 접두사 사용)**
    - 소프트 딜리트 처리 시, LoginId에 타임스탬프, UUID, 또는 특정 접두사를 추가하여 고유성을 깨뜨리는방법. 예를 들어, 사용자가 탈퇴하면 LoginId를 "deleted_" + 원래 LoginId로 변경할 수 있습니다

- 채택
  - **로그인 ID 변경 (타임스탬프(초단위 까지) 접두사 사용)**
  - 이유
    - 데이터베이스 구조나 인덱스 설정을 변경할 필요가 없어, 유니크 인덱스 관리가 쉬움
    - 특별한 데이터베이스 기능을 요구하지 않아 호환성이 좋음.

### 3. Access-Token, Refresh-Token Secret-Key 분리

- 일반적으로?는 하나의 Secret-key를 이용해 Access-Token, Refresh-Token을 생성하는 거 같음. 그러나 하나의 Secret-Key를 사용하면 refresh_token을 헤더에 access_token 대신 담아서 보내도 인증이 허가가 됨

- 각 토큰의 용도에 맞는 역할만 수행하기 위해 토큰 별로 Secret-Key를 달리하여 토큰을 생성하기로 함



### 4. Security에 커스텀 필터인 JwtAuthenticationFilter를 등록하고 사용하는데 1번의 request가 해당 필터를 자꾸 2번 실행하는 에러 (필터 중복 등록 에러)

- 참고 : [바로가기](https://shanepark.tistory.com/497)

- **원인**

  - `JwtAuthenticationFilter`를 간편하게 Bean으로 등록 해두고 사용하려고 클래스에 `@Component` 어노테이션을 붙여서 사용했는데 그게 원인으로 추정 됨

  - 스프링 빈으로 등록된 Servlet, Filter, Listener 인스턴스들은 내장 컨테이너에 자동으로 등록 됨. 특히 Filter 빈을 등록하면 어플리케이션의 생명주기에서 매우 이른시기에 등록되기 때문에 다른 빈들과 상호작용이 필요하다면 `DelegatingFilterProxyRegistrationBean` 을 고려하라고 함.

    > 예전에 스프링 프레임워크를 배울때는 필터와 인터셉터의 차이에 대해 스프링의 관여 여부를 따지곤 했었는데, `DelegatingFilterProxyRegistrationBean` 덕분에 스프링이 관리하는 필터도 서블릿 필터 체인에 등록할 수 있게 되었다.

  - 그러니 원인을 분석해보자면 똑같은 필터가 자동으로, 수동으로 총 2번 등록되었다는 이야기다. 자동으로 등록된 필터의 문제점은, URL 패턴 없이 그냥 모든 요청을 대상으로 다 적용이 되며 특히 순서를 보장하기도 굉장히 까다롭다는 것이다.

- **해결**

  - 필터가 자동으로 등록되지 않도록 `@Component` 어노테이션을 제거한다.

  - 스프링 시큐리티 설정파일에서는 해당 `Filter`를 생성자를 통해 생성해 필터체인에 등록

    ```java
    public class SecurityConfig {
    
        private final ObjectMapper objectMapper;
        private final JwtUtil jwtUtil;
        private final CustomUserDetailsService customUserDetailService;
        private final CustomAuthenticationSuccessHandler customAuthenticationSuccessHandler;
        private final CustomAuthenticationEntryPoint customAuthenticationEntryPoint;
    
    
        @Bean
        public SecurityFilterChain filterChain(HttpSecurity httpSecurity, AuthenticationManager authenticationManager) throws Exception {
            LoginIdAuthenticationFilter loginIdAuthenticationFilter = new LoginIdAuthenticationFilter(authenticationManager, customAuthenticationSuccessHandler, objectMapper);
            JwtAuthenticationFilter jwtAuthenticationFilter = new JwtAuthenticationFilter(jwtUtil, objectMapper);
            return httpSecurity
                    .formLogin(AbstractHttpConfigurer::disable)
                    .httpBasic(AbstractHttpConfigurer::disable)
                    .csrf(AbstractHttpConfigurer::disable)
                    .sessionManagement(management ->
                            management.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                    .authorizeHttpRequests(authorize -> authorize
                            .requestMatchers(HttpMethod.POST, "/users")
                            .permitAll()
                            .requestMatchers("/users/check", "/auth/login", "/auth/device/login","auth/reissue")
                            .permitAll()
                            .anyRequest().authenticated())
                    .exceptionHandling((exceptionConfig) ->
                            exceptionConfig.authenticationEntryPoint(customAuthenticationEntryPoint))
                    .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                    .addFilterAt(loginIdAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                    .build();
        }
    ```

    

### 5. userRepository의 save메서드에서 duplicate key 에러가 발생했는데, 응답이 CustomAuthenticationEntryPoint의 코드로 처리 되는 버그 (필터 중복 등록과 chain.dofilter()메서드 문제로 생각함)
