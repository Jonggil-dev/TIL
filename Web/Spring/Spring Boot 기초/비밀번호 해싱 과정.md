# 비밀번호 해싱 과정

- **해싱의 안전성을 늘리기 위한 과정(라운드 수 증가, 솔트 등)들은 데이터 베이스가 해킹되어 해싱된 값이 탈취 됐을 때를 고려하여 설계 된 것 (막말로 원본 비밀번호를 탈취 당하면 답이 없음)**



### 1. 비밀번호 해싱 과정

1. **비밀번호 수집**: 사용자가 비밀번호를 입력
   - 예: 사용자가 비밀번호 "mypassword"를 입력합니다.

2. **솔트 생성**: 해시 충돌을 방지하기 위해 랜덤한 솔트를 생성 
   - 예: 솔트 값이 "randomsalt123"라고 가정합니다.

3. **해시 계산**: 비밀번호와 솔트를 결합하여 해시 알고리즘을 사용해 해시값을 계산. 이 과정에서 여러 라운드를 수행 (아래 참고)
   - 예를 들어, Bcrypt 알고리즘을 사용하고 라운드 수가 10이라고 가정합니다.
4. **해시값 저장**: 최종 해시값과 솔트를 데이터베이스에 저장
   - 예: 저장된 해시값이 "$2b$10$abcdefg1234567890"이고, 솔트는 "randomsalt123"입니다.



### 2. 라운드 진행 예시

- **1라운드**:  
  - 입력: "mypasswordrandomsalt123"
  - 해시 계산: 해시 함수가 이 입력값을 처리하여 첫 번째 해시값을 생성합니다.
- **2라운드**:  
  - 입력: 첫 번째 해시값 + 솔트 (randomsalt123)
  - 해시 계산: 두 번째 해시값을 생성합니다.

이 과정을 10라운드 반복



### 3. 라운드 수의 중요성 

- **시간 소모 증가**: 해싱을 여러 라운드로 수행하면 각 비밀번호에 대한 해시를 생성하는 데 더 많은 시간이 걸립니다. 이는 해커가 비밀번호 목록을 모두 시도하는 데 필요한 총 시간이 크게 증가합니다.
- **컴퓨팅 리소스 필요**: 해커는 자신의 컴퓨터에서 해시를 계산해야 하므로, CPU 자원을 소모하게 됩니다. 비밀번호와 솔트를 결합하여 해시를 여러 번 계산해야 하므로, 더욱 많은 계산 능력이 필요합니다.

- (예시) 공격 시나리오: 해커가 비밀번호를 유추하려고 할 때
  1. 해커가 데이터베이스를 해킹하여 사용자 정보와 함께 해시된 비밀번호를 탈취
  2. 해커는 공격에 사용할 해시 함수를 구현하여 브루트 포스로 해시된 비밀번호의 원본을 유추하려 함
  3. 이 때 라운드가 증가할 수록 각 비밀번호에 대한 해시를 생성하는 데 더 많은 시간과 컴퓨팅 리소스가 소요됨




### 4. 솔트의 필요성

- **해시 충돌 방지**: 동일한 비밀번호를 가진 사용자라도 서로 다른 해시값을 갖도록 보장합니다.
- **무차별 대입 공격 방어**: 해커가 미리 계산된 해시값(레인보우 테이블 등)을 사용하는 것을 방지하여, 각 비밀번호에 대해 독립적인 해시를 생성합니다.
- **추가 보안**: 솔트를 사용하면 해시값을 역산하는 데 필요한 계산을 더욱 복잡하게 만들어, 비밀번호 유추를 어렵게 합니다.