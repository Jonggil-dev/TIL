# 3. 정렬 알고리즘

### 1. 선택정렬(Selection sort)

- 비교군 중 가장 작은 데이터를 선택해 비교군의 맨 앞에 있는 데이터와 바꿈

- 시간복잡도 O(N^2)
  
  ```python
  #선택정렬
  
  Arr = [7,5,9,0,3,1,6,2,4,8]
  for i in range(len(Arr) - 1):
      min_index = i        #비교군 중 가장 작은 원소의 인덱스
      for j in range(i + 1, len(Arr)):
          if arr[min_index] > arr[j]:
              min_index = j
      arr[i],arr[min_index] = arr[min_index],arr[i]    
  ```

### 2. 삽입정렬(Insertion sort)

- 데이터를 하나씩 확인하며, 해당 데이터보다 앞에 위치한 원소들과 비교하여 적절한 위치에 삽입함 (그래서 두 번째 인덱스 부터 시작함)

- 필요할 때만 위치를 바꾸므로 **'데이터가 거의 정렬되어 있을 때' 굉장히 효율적**
  
  ```python
  #삽입정렬
  
  Arr = [7,5,9,0,3,1,6,2,4,8]
  for i in range(1, len(Arr)):
      for j in range(i, 0, -1):
          if Arr[j - 1] > Arr[j]:
              Arr[j - 1],Arr[j] = Arr[j],Arr[j - 1]
          else:
              break
  ```

### 3. 퀵 정렬(Quick sort)

- 피벗(기준) 데이터를 설정하고 그 피벗보다 큰 데이터와 작은 데이터의 위치를 바꿈

- 피벗을 설정하고 리스트를 분할하는 방법에 따라 여러 방식으로 구분
  
  - 호어 분할방식
    
    (1) 피벗을 설정한 뒤 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾음
    
    (2) 큰 데이터와 작은 데이터의 위치를 서로 교환
    
    (3) 큰 데이터와 작은 데이터의 위치가 엇갈린 경우 작은 데이터와 피벗 위치를 변경
    
    (4) 피벗의 왼쪽에는 피벗보다 작은 데이터, 오른쪽에는 큰 데이터만 위치하게 됨

- 정렬 라이브러리의 근간이 되는 가장 많이 사용하는 정렬 알고리즘

- **이미 정렬이 되어 잇는 경우에는 매우 느리게 동작함**

- **평균 시간 복잡도가 O(N * logN)인 이유**

  - 각 배열의 크기가 1이 될 때 까지, 분할 단계가 평균적으로 log2N번 수행 됨 * 각 분할 단계별로 정렬을 수행하기 위해 결국 모든 원소를 순회하는 N번 조회 연산이 발생 => N * log2N
    - **분할 단계**: 퀵 정렬은 피벗을 기준으로 배열을 두 부분으로 나누는 '분할' 과정을 수행합니다. 이 과정에서 배열의 크기는 반으로 줄어들며, 이 과정이 log2N번 반복됩니다.
      - 처음 배열의 크기가 N, 첫 번째 분할 후 N/2, 두 번째 분할 후 N/4
      - 결국 각 배열의 크기가 1이 되는 지점, 즉 N/(2^k)이 될 때 까지 수행 됨. N/(2^k)=1이 되는 k의 값이 log⁡2N입니다.

    - **작업량**: 각 분할 단계에서 전체 원소 N에 대해 비교 및 이동 작업을 수행하므로, 각 단계의 작업량은 O(N)입니다.
    - **총 작업량**: 분할 단계가 log⁡N번 반복되고 각 단계에서 O(N)의 작업을 수행하므로, 전체 시간 복잡도는 O(Nlog⁡N)이 됩니다.


```python
# 퀵 정렬(파이썬 특화)

def quick_sort(Arr):
    if len(Arr) <= 1:
        return Arr

    piviot = Arr[0]
    tail = Arr[1:]
    
    left_side = [x for x in tail if x <= pivot]
    right_side = [x for x in tail if x > pivot]

    return quick_sort(left_side) + [pivot] + quick_sort(right_side)
```

### 4. 계수 정렬(Countting sort)

- 별도의 카운트 리스트에 정렬이 필요한 리스트의 숫자가 등장하는 횟수를 담아 출력하는 방법 
  
  → 출력은 인덱스 번호에 기록된 숫자만큼 개수를 순서대로 출력함

- **특정한 조건이 부합할 때만 사용할 수 있지만, 매우 빠른 정렬 알고리즘**

- 조건 : 데이터의 크기 범위가 제한되고 정수 형태로 표현할 수 있을 때만 사용가능

```
# 모든 범위를 포함하는 리스트 선언
Arr = [7,5,9,0,3,1,6,2,9,1,4,8,0,5,2]
# 원소의 값이 0보다 크거나 같다고 가정
count = [0] * (max(Arr)+1)

for i in range(len(Arr)):
    count[Arr[i] += 1

for i in range(len(count)):
    for _ in range(count[i]):
        print(j, end=")
```
