# 2. DFS / BFS

### 1. 탐색/자료구조

- 탐색 : 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
  
              → 대표적인 탐색 알고리즘 : DFS, BFS

- 자료구조 : 데이터를 표현하고 관리하고 처리하기 위한 구조

                   → 리스트, 딕셔너리, 스택, 큐 등

### 2. 스택(Stack) / 큐(Queue)

- 스택(Stack) : 후입 선출(Last In First Out) 방식의 선형 자료구조

- 큐(Queue) : 선입 선출(First In First Out) 방식의 선형 자료구조 

                             → collections 모듈의 deque 자료구조 사용하기

### 3. 재귀함수

- 자기 자신을 다시 호출하는 함수

- 종료 조건을 반드시 명시해야 함

- 컴퓨터 구조 측면에서 재귀 함수는 내부적으로 메인 메모리의 스택 공간에 적재되므로 스택 자료구조와 동일함

- 소스코드가 점화식과 유사함

### 4. 그래프

- 노드(Node)와 간선(Edge)로 표현되는 비선형 자료구조

- 크게 인접 행렬, 인접 리스트 2가지 방식으로 표현 
  
  (1) 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
  
  - 메모리 공간의 낭비가 있으나, 노드 정보를 얻는 속도가 빠름
  
  (2) 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식
  
  - 메모리 공간의 낭비가 적으나, 노드 정보를 얻는 속도가 느림

```
# 인접 행렬 방식
INF = 999999999 # 무한의 비용 선언
graph = [
    [0,7,5],
    [7,0,INF],
    [5,INF,0]
]

# 인접 리스트 방식
graph = [[(1,7),(2,5)], [(0,7)],[(0,5)]]
```

### 5. DFS(Depth-First Search)

- 깊이 우선 탐색 : 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘 

  - 재귀함수 이용

    ```
    # DFS 예시코드(재귀함수 이용)
    def dfs(graph,v,visited):
        # 현재 노드 방문 처리
        visited[v] = True
        # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
        for i in graph[v]:
            if not visited[i]:
            	visited[i] = 
                dfs(graph,i,visited)
    ```

  - 스택 이용

    - BFS에서 queue를 그냥 stack으로만 바꾸기만 해도 됨
    - 그런데 방문 처리의 일관성에 맞게 하기 위해 그냥 방문처리 타이밍도 pop했을 때로 바꿔줌

    ```
    # DFS 예시코드(스택 이용)
    
    def dfs(graph,start,visited):
        stack = [start]
        while queue:
            v = stack.pop()
            visited[start] = True
            for i in graph[v]
                if not visited[i]:
                    stack.append(i)
    ```

### 6. BFS(Bredth Fisrt Search)

- 너비 우선 탐색 : 가까운 노드부터 탐색하는 알고리즘

```
# BFS 예시코드(Queue 이용)
from collections import deque

def bfs(graph,start,visited):
    queue = deque([start])
    visited[start] = True
    while queue:
        v = queue.popleft() 
        for i in graph[v]
            if not visited[i]:
                queue.append(i)
                visited[i] = True
```



### 7. 참고

- 재귀, 스택, 큐 모두 방문 처리 방법을 2가지로 해서 구현이 가능함

  - 실제 방문을 했을 때 방문 처리를 하는 방법
    - 재귀의 경우 dfs함수가 호출 되고 for 문이 돌기 전 방문 처리 
      (위의 예시 코드가 해당)
    - 스택, 큐의 경우 pop() 을 했을 때 방문처리
  - 방문 대상이 될 때 방문 처리를 하는 방법
    - 재귀의 경우 dfs함수를 호출하기 직전 for문이 돌면서 방문 처리
    - 스택, 큐의 경우 for문이 돌고 append를 하기 직전 방문처리

- **권장 방법 (재귀 / 큐,스택의 방법 차이로 인해 권장 방법이 결정)**

  - **큐, 스택에서는 '방문 대상으로 등록할 때 처리하기' 방식이 일반적으로 더 효율적임**. 
    
    - 큐에 노드를 추가하기 전에 방문 처리를 하면 중복으로 방문지로 등록되는 것(큐나 스택에 노드가 중복으로 들어가는 것)을 방지할 수 있음
    - 방문시에 방문처리를 하고 큐나 스택에에 넣기전에 중복 검사를 해도 되는데 코드가 비효율적으로 보임
    
  - **재귀에서는 어느 것을 사용해도 성능에 큰 차이가 없음
    (헷갈리면 그냥 DFS든 BFS든 방문 대상이 될 때 방문처리를 하는걸로 통일하기)** 
    
    - 재귀 함수의 경우 어짜피 동작 과정을 생각해보면 위 2가지 방문 처리 방식 모두, 방문 처리와 노드의 탐색이 바로 연결되기 때문에 상관없음 -> 근데 백트래킹 생각하면 방문 대상이 되기 직전에 방문처리를 하고, 함수 호출하고, 다시 방문처리를 취소하는게 코드 상 깔끔해보임
    
      
