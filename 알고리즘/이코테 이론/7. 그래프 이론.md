# 7. 그래프 이론

### 0. 발상

- 그래프 : 노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조

- **''서로 다른 개체가 연결되어 있다''라는 이야기를 듣거나 떠오르면 그래프 알고리즘을 의심해 보기**

  

### 1. 그래프 vs 트리

|                     |             그래프             |       트리       |
| :-----------------: | :----------------------------: | :--------------: |
|       방향성        | 방향 그래프 혹은 무방향 그래프 |   방향 그래프    |
|       순환성        |         순환 및 비순환         |      비순환      |
| 루트 노드 존재 여부 |        루트 노드가 없음        | 루트 노드가 존재 |
|    노드간 관계성    |     부모와 자식 관계 없음      | 부모와 자식 관계 |
|     모델의 종류     |         네트워크 모델          |    계층 모델     |



### 2. 인접 행렬 vs 인접 리스트

- 노드의 개수 V, 간선의 개수 E 인 경우

  - 인접 행렬 : 메모리 O(V<sup>2</sup>) , 간선 확인 시간 O(1)
  - 인접 리스트 : 메모리 O(E), 간선 확인 시간 O(V)

  

### 3. 서로소 집합(Disjoint Sets)

​	(1) 서로소 집합(Disjoint Sets)

​		: 공통 원소가 없는 두 집합

​	(2) 서로소 집합 자료구조(Union-Find 자료구조) 

​		● 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조, **트리 자료구조를 이용하여 집합을 표현함**

​		● 스택과 큐가 push, pop 2개로 동작하는 것처럼, **서로소 집합 자료구조는 union과 find 2개의 연산으로 조작함**



### 4. 서로소 집합 계산 알고리즘(Union-Find)

```tex
● union(합집합) : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
● find(찾기) : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산


# 알고리즘
1. union(합집합) 연산을 확인하여, 서로 연결된 두 노드 A,B를 확인한다.
	(1) A와 B의 루트 노드 A',B'를 각각 찾는다.
	(2) A'를 B'의 부모 노드로 설정한다(B'가 A'를 가리키도록 한다)
2. 모든 union(합집합) 연산을 처리할 때까지 1번 과정을 반복한다.

※ 실제로 구현할 때는 더 번호가 작은 원소가 부모 노드가 되도록 구현하는게 일반적임
(반대로 해도 상관 없음)
```

````python
# 서로소 집합 알고리즘 소스코드

```
1. find 함수는 루트 노드를 찾으면서 동시에 루트 노드(제일 윗단의 부모노드)로 갱신이 되어 있지 않은경우 갱신까지 동시 진행함
2. union 함수는 뭉탱이와 뭉탱이가 연결되는 부분이 나오면 뒤에 뭉탱이의 루트 노드 외 원소는 갱신이 되지 않으므로 find를 별도로 시켜 줘야됨 (맨 마지막의 input값이 뭉탱이와 뭉탱이가 아닌 경우에는 이전에 union함수 실행시 계속 find함수가 실행되므로 별도 필요없긴 함 -> 이러한 엣지 케이스들의 발생을 처리하기 위해 루트 노드 비교가 필요할 시 parents[a]와 parents[b]를 비교하는게 아니라 find_parent(a)와 find_parent(b) 값을 비교 함)
```

def find_parent(parent,x): # 특정 원소가 속한 집합 찾기
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
    if parent[x] != x:
        parent[x] = find_parent(parent,parent[x])
    return parent[x]

def union_parent(parent,a,b) # 두 원소가 속한 집합을 합치기
    a = find_parent(parent,a)
    b = find_parent(parent,b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선(union 연산)의 개수 입력받기
v, e = map(int,input().split())
parent = [0] * (v+1) #부모 테이블 초기화

# 부모 테이블 상에서, 부모를 자기 자신으로 초기화
for i in range(1, v+1):
    parent[i] = i

# union 연산을 각각 수행
for i in range(e):
    a,b= map(int,input.split())
    union_parent(parent,a,b)

# 각 원소가 속한 집합 출력
print('각 원소가 속한 집합 : ', end = ' ')
for i in range(1,V+1):
    print(find_parent(parent,i), end = ' ')

print()

# 부모 테이블 출력
print('부모테이블 :', end = ' ')
print(*parent)
````



※ 참고

- 서로소 집합을 활용해서 사이클(순환) 반별 소스코드 (279page 참고)

  -  그냥 백지에서 연결된 2개 노드를  하나씩 생성해 나가는 걸 상상하면 쉬움.

  - 추가되는 2개의 노드가 이미 연결되어 있던 집합 무리에 속해 있을경우 사이클이 된다는 것을 알 수 있음.
  
  - ##### 위의 서로소 집합 알고리즘 소스코드에서 ''부모를 자기 자신으로 초기화' ' 다음 순서 부분 아래 코드로 바꾸면 됨
  
  ```python
  # 사이클(순환) 판별 소스코드
  cycle = False # 사이클 발생 여부
  
  for i in range(e):
  	a,b = map(int,input().split())
      # 사이클 발생한 경우 종료
      if find_parent(parent,a) == find_parent(parent,b):
          cycle = True
          break
      # 사이클이 발생하지 않았다면 합집합(union) 수행
  	else:
          union_parent(parent,a,b)
      
  if cycle:
      print("사이클")
  else:
      print("사이클 없음")
  ```
  
  

### 5. 신장 트리

- 신장트리 : 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프 



### 6. 크루스칼 알고리즘

##### 	(0) ★ 이해하는 원리 ★

​		● 그냥 백지에서 최소 비용을 가지는 2개 노드를  하나씩 순서대로 생성해 나가는 걸 상상하면 쉬움.

​		● 위의 과정을 상상하면 2개의 노드가 이미 연결되어 있던 집합 무리에 속해 있을경우 사이클이 된다는 것을 알 수 있음.

​	(1) 정의

​		● 최소 비용으로 모든 노드를 연결하는 신장 트리를 찾는 알고리즘 → '최소 신장 트리 알고리즘' 이라고도 함

​		● 모든 간선에 대하여 정렬을 수행한 뒤에 가장 거리가 짧은 간선부터 집합에 포함시키는 과정으로 그리디 알고리즘으로 분류됨

​		● 간선의 개수가  E개일 때, O(ElogE) 시간 복잡도를 가짐 : 간선을 정렬하는 작업이 가장 오래 소요됨	

##### 	(2) 알고리즘

##### 		● 간선 데이터를 비용에 따라 오름차순으로 정렬한다.

##### 		● 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다.

​			1) 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.

​			2)사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.   

##### 		● 모든 간선에 대하여 (2)의 과정을 반복한다.

##### 	(4) 코드

​	●  위의 서로소 집합 알고리즘 소스코드에서 ''부모를 자기 자신으로 초기화' ' 다음 순서 부분 아래 코드로 바꾸면 됨

```python
# 모든 간선을 담을 리스트와 최종 비용을 담을 변수 생성
edges = []
result = 0

# 모든 간선에 대한 정보를 입력받기
for _ in range(e):
    a,b,cost = map(int,input().split())
    # 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 비용으로 설정
    edges.append((cost,a,b))
    
# 간선을 비용순으로 정렬
edges.sort()

#간선을 하나씩 확인하며
for edge in edges:
    cost,a,b = dege
    # 사이클이 발생하지 않는 경우에만 집합에 포함
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent,a,b)
        result += cost

print(result)
    
```



### 7. 위상 정렬

​	(1) 정의

​		● 방향 그래프의 모든 노드를 **'방향성에 거스리지 않도록 순서대로 나열하는 것'**

​		● 시간 복잡도 : O(V+E)

​	(2) 용어

​		●  진입차수 : 특정한 노드로 들어오는 간선의 개수

​		●  진출차수 : 특정한 노드로 들어오는 간선의 개수 

##### 		(3) 알고리즘

##### 				● 진입차수가 0인 노드를 큐에 넣는다

##### 				● 큐가 빌 때까지 다음의 과정을 반복한다.

​			1) 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.

​			2) 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.

##### 				※ 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단할 수 있음 : 사이클이 있는 노드는 진입차수가 0이 안되기 때문

##### 		(4) 코드

``` python
from collections import deque

# 노드의 개수와 간선의 개수를 입력받기
v,e = map(int,input().split())
# 모든 노드에 대한 진입차수는 0으로 초기화
indegree = [0] * (v+1)
# 각 노드에 연결된 간선 정보를 담기 위한 연결 리스트(그래프) 초기화
graph = [[] for i in range(v+1)]

# 방향 그래프의 모든 간선 정보를 입력받기
for _ in range(e):
    a,b = map(int,input().split())
    graph[a].append(b) # 정점 A에서 B로 이동 가능
    # 진입차수를 1 증가
    indegree[b] += 1
    
# 위상 정렬 함수
def topology_sort():
    result = [] # 알고리즘 수행 결과를 담을 리스트
    q = deque() # 큐 기능을 위한 deque 라이브러리 사용
    
    # 처음 시작할 때는 친입차수가 0인 노드를 큐에 삽입
    for i in range(1,v+1):
        if indegree[i] == 0:
            q.append(i)
    
    # 큐가 빌 때까지 반복
    while q:
        # 큐에서 원소 꺼내기
        now = q.popleft()
        result.append(now)
        # 해당 원소와 연결된 노드들의 진입차수에서 1 빼기
        for i in graph[now]:
            indegree[i] -= 1
            # 새롭게 진입차수가 0이 되는 노드를 큐에 삽입
            if indegree[i] == 0:
                q.append(i)
    # 위상 정렬을 수행한 결과 출력
    for i in result:
        print(i, end="")

topology_sort()
```

